\documentclass[a4paper,10pt]{report}
\usepackage[utf8]{inputenc}

\usepackage{pattern}
\usepackage{listings}
\usepackage{todo}

% Title Page
\title{Concurrency Patterns in SCOOP}
\author{Roman Schmocker}


\begin{document}
\maketitle

\begin{abstract}

\end{abstract}

\section{Introduction}

\section {The SCOOP model}
% Introduction, differences to Java etc... (short)

\section {Pattern overview}
% Overview of all patterns, maybe tabular

\pattern [ name={Single Exclusive Access}
  ,category={Synchronization Primitive}
  ,intent={Make sure that at most one thread has access to exactly one shared object or resource.}
  ,applicability={Shared memory systems}
  ,status={Implemented language mechanism}
  ,example={A counter variable that shold only be incremented by one thread at a time to avoid lost updates.}
  ,knownapps={The Java ``synchronized'' block implements single exclusive access, as well as C\# ``lock''.}
  ,relation={Usually implemented with some kind of locking mechanism.}
  ]

\pattern [ name={Multiple Exclusive Access}
  ,category={Synchronization Primitive}
  ,intent={Make sure that at most one thread has access to several shared objects or resources.}
  ,applicability={Shared memory systems}
  ,status={Implemented language mechanism}
  ,example={A money transfer between two bank accounts.}
  ,knownapps={Databases can provide exclusive access over all data previously used in the same transaction.}
  ,relation={It is possible to use nested single exclusive access to provide multiple exclusive access, but special care has to be taken with deadlocks.}
  ]

\pattern [ name={Import}
  ,category={Language limitation}
  ,intent={Copy an object structure from a separate processor to the local processor.}
  ,applicability={SCOOP only. Requires some client support.}
  ,status={Implemented library component; future language mechanism}
  ,example={Copy the HTTP request from the network socket listener to a request handler, such that the listener can continue.}
  ,knownapps={The library makes heavy use of this pattern.}
%  ,relation={}
]

\pattern [ name={Self Asynch}
  ,category={Program structuring}
  ,intent={Allow other processors to access and modify data on the current processor despite running in a main loop.}
  ,applicability={SCOOP only}
  ,status={Implemented library component}
  ,example={A network socket listener that may be stopped by another process.}
  ,knownapps={The timer pattern and the echo server use self asynch.}
  ,relation={Similar to the Active Object pattern, except that other processors may access data after each iteration.}
]

\pattern [ name={Separate Proxy}
  ,category={Program structuring}
  ,intent={Provide easy access to a separate object.}
  ,applicability={SCOOP only}
  ,status={Guideline}
  ,example={A shared buffer in a producer / consumer setting, where every producer and consumer creates a proxy on its own processor to avoid dealing with separate references.}
  ,knownapps={The CP\_BROKER and CP\_QUEUE classes have predefined proxies.\todo {inline listings}}
  ,relation={The separate proxy is a special version of the more general GoF \todo{ref} proxy pattern.}
]

\pattern [ name={Future}
  ,category={Program structuring, Performance}
  ,intent={Run a task asynchronously, and fetch the result later.}
  ,applicability={Asynchronous operations}
  ,status={Implemented library component, implemented language mechanism.}
  ,example={Download a file in the background.}
  ,knownapps={UI programming, downloader tasks, IO operations...}
  ,relation={Futures may be backed by worker pools that execute them.}
]

\pattern [ name={Producer / Consumer}
  ,category={Program structuring}
  ,intent={Pass data items from producers to consumers via a shared buffer}
  ,applicability={Shared memory systems}
  ,status={Implemented library component.}
  ,example={A logger service, where many producers submit log messages to a buffer and a single consumer writes them to a file.}
  ,knownapps={Logging, input processing, pipeline...}
  ,relation={The worker pool uses this pattern to pass along tasks.}
]
\pattern [ name={Thread specific storage}
  ,category={Program structuring}
  ,intent={Provide per-thread singletons.}
  ,applicability={Shared memory systems}
  ,status={Implemented language mechanism.}
  ,example={Store the last exception raised in the current thread.}
%  ,knownapps={}
%  ,relation={}
]

\pattern [ name={Timer: Invoke later}
  ,category={Program structuring}
  ,intent={Invoke a certain operation once at a later point in time.}
%   ,applicability={}
  ,status={Implemented library component}
  ,example={Send an email after a delay of one minute.}
%   ,knownapps={}
%   ,relation={}
]

\pattern [name={Worker Pool}
  ,category={Performance}
  ,intent={Avoid expensive thread cration by providing a set of threads that can execute arbitrary operations.}
  ,applicability={}
  ,status={Implemented library component}
  ,example={A set of HTTP request handlers in a web server.}
  ,knownapps={The Java Executor service is usually backed by a worker pool.}
%   ,relation={}
]

\pattern [name={Executor framework}
  ,category={Program structuring}
  ,intent={Split task submission from task execution}
%   ,applicability={}
  ,status={Implemented library component.}
  ,example={The Java Executor interface which has implementations for a worker pool or a single thread.}
%   ,knownapps={}
%   ,relation={}
]

\pattern [name={Publish / Subscribe}
  ,category={Program structuring}
  ,intent={Provide a service for event subscription and delievery, where the publisher doesn't need to know the subscribers.}
%   ,applicability={}
%   ,status={}
  ,example={A GUI button has an event ``clicked'', where the application logic can provide a handler.}
  ,knownapps={GUI frameworks like Java Swing or EiffelVision.}
%   ,relation={}
]

\pattern [name={EiffelVision support}
%   ,category={}
%   ,intent={}
%   ,applicability={}
%   ,status={}
%   ,example={}
%   ,knownapps={}
%   ,relation={}
]

\pattern [name={Handshake}
  ,category={Synchronization primitive}
  ,intent={Send a message from sender to receiver synchronously, where both must wait until the operation has completed.}
%   ,applicability={}
%   ,status={}
%   ,example={}
%   ,knownapps={}
%   ,relation={}
]

\pattern [name={Pipeline}
  ,category={Program structuring}
  ,intent={Split processing of input into separate individual stages.}
%   ,applicability={}
%   ,status={}
  ,example={An emailing system that applies a spam filter, database logging, and a virus scan to each incoming email.}
  ,knownapps={Messaging systems, input processing}
  ,relation={This is like a chained producer / consumer}
]

\pattern [name={Timer: Periodic}
  ,category={Program structuring}
  ,intent={Apply an operation repeatedly with a small wait time in between.}
%   ,applicability={}
  ,status={Implemented library component}
  ,example={An emailing application that checks for new messages every five seconds.}
%   ,knownapps={}
%   ,relation={}
]

\pattern [name={Barrier}
  ,category={Synchronization primitive}
  ,intent={Provide a synchronization point where several threads have to meet before continuing.}
%   ,applicability={}
  ,status={Possible library component}
  ,example={If the computation of a matrix multiplication is split among threads, the barrier can be used to make sure that all threads finish before the result can be used}
%   ,knownapps={}
%   ,relation={}
]

\pattern [name={Condition Variables}
  ,category={Synchronization primitive}
  ,intent={Wait for a certain condition to become true.}
%   ,applicability={}
  ,status={Implemented language feature, possible library component}
  ,example={When a buffer is empty, a consumer can wait on the is\_not\_empty conditon variable. Producers will signal on this variable when a new item is available.}
  ,knownapps={Preconditions in SCOOP are effectively condition variables, due to their wait semantics.}
%   ,relation={}
]


\pattern [name={TryLock}
  ,category={Synchronization primitive}
  ,intent={Try to acquire a lock, with the option to back off after a certain amount of time.}
%   ,applicability={}
  ,status={Possible library component}
  ,example={Database transactions may get aborted due to a timeout if they can't lock a resource after a certain amount of time.}
%   ,knownapps={}
%   ,relation={}
]

\pattern [name={Dataflow Network}
  ,category={Program structuring}
  ,intent={Process input in several stages, with the option to process them in parallel at some points.}
%   ,applicability={}
  ,status={Possible library component}
  ,example={A video player application that internally has a file decoder stage, which splits the input in an audio and video part, which then gets further processed.}
%   ,knownapps={}
  ,relation={This is a more generalized form of the pipeline pattern.}
]

\pattern [name={Transactions}
  ,category={Program structuring}
  ,intent={Avoid a deadlock by ``reserving'' a set of objects one at a time.}
%   ,applicability={}
%   ,status={}
%   ,example={}
%   ,knownapps={}
%   ,relation={}
]

\pattern [name={Fully Asynch}
%   ,category={}
%   ,intent={}
%   ,applicability={}
%   ,status={}
%   ,example={}
%   ,knownapps={}
%   ,relation={}
]

\pattern [name={Universal Call}
%   ,category={}
%   ,intent={}
%   ,applicability={}
%   ,status={}
%   ,example={}
%   ,knownapps={}
%   ,relation={}
]

\pattern [name={Atomic Operations}
  ,category={Synchronization primitive}
  ,intent={Avoid the use of locks by using hardware-supported atomic operations.}
  ,applicability={Shared memory systems}
  ,status={unsolved}
%   ,example={}
%   ,knownapps={}
%   ,relation={}
]

\pattern [name={Monitor}
  ,category={Synchronization primitive}
  ,intent={Ensure that only one thread has access to an object. The thread may also wait on a condition to become true.}
%   ,applicability={}
  ,status={Implemented language mechanism.}
%   ,example={}
%   ,knownapps={}
  ,relation={The monitor pattern can be seen as a combination of single exclusive access and condition variables.}
]

\pattern [name={Read / Write lock}
  ,category={Synchronization primitive}
  ,intent={Allow multiple concurrent readers, but provide exclusive access to a single writer.}
%   ,applicability={}
  ,status={Language limitation}
  ,example={A shared array with frequent concurrent reads can make use of a read / write lock.}
%   ,knownapps={}
%   ,relation={}
]

\pattern [name={Semaphore}
  ,category={Synchronization primitive}
%   ,intent={Control the amount of threads that may pass a certain section.}
%   ,applicability={}
%   ,status={Possible library component.}
%   ,example={}
%   ,knownapps={}
%   ,relation={Similar to a barrier.}
]

\pattern [name={Active Object}
  ,category={Program structuring}
  ,intent={Assign a thread to an object. Calls to this object correspond to messages with operations to be executed.}
%   ,applicability={}
  ,status={Implemented language mechanism. Implemented library component.}
%   ,example={}
%   ,knownapps={}
%   ,relation={}
]

\pattern [name={Disruptor}
%   ,category={}
%   ,intent={}
%   ,applicability={}
%   ,status={}
%   ,example={}
%   ,knownapps={}
%   ,relation={}
]
% 
\pattern [name={Leader / Follower}
%   ,category={}
%   ,intent={}
%   ,applicability={}
%   ,status={}
%   ,example={}
%   ,knownapps={}
%   ,relation={}
]

\section {Library}

The library is designed as a set of modules which simplify concurrent programming in SCOOP.
Section ~\ref{sec:tutorial} explains how to use the library for commonly used patterns,
while Section ~\ref{sec:modules} concentrates on the design of the library itself.

\subsection {API tutorial}
\label{sec:tutorial}

\subsubsection{Producer / Consumer}

The producer / consumer example is pretty common in concurrent programming.
At its core is usually a shared buffer.
A producer can add items to the buffer, whereas a consumer removes items from the buffer.

The library class \lstinline!CP_QUEUE! can be used as a shared buffer.
If we want to use \lstinline!STRING! objects to be passed from producer to consumer, we have to declare the queue like this:

\begin{lstlisting}
class PRODUCER_CONSUMER feature

  make
      -- Launch producers and consumers.
    local
      queue: separate CP_QUEUE [STRING, CP_STRING_IMPORTER]
	-- ...
    do
      create queue.make_bounded (10)
	-- ...
    end
end
\end{lstlisting}

Note that there are two generic arguments:
\begin{itemize}
\item The first argument (\lstinline!STRING!) denotes the type of items in the queue.
\item The second argument (\lstinline!CP_STRING_IMPORTER!) defines the import strategy.
\end{itemize}

The import strategy is an important concept of the library.
An import in the SCOOP context means that an object on a separate processor should be copied to the local processor.
This is done recursively for any non-separate reference, i.e. for  \lstinline!STRING! you also have to copy the \lstinline!area! attribute.
The import strategy can be used to tell a component if a given object should be imported, and if yes, how it is done.

In our example we're using the \lstinline!CP_STRING_IMPORTER! to import strings.
An alternative would be to use \lstinline!CP_NO_IMPORTER [STRING]! if we want to disable imports.

The next step we need to do is to define the producer and consumer.

\lstinputlisting [firstline=7] {../../examples/producer_consumer/producer.e}

You may notice three things in this example:

\begin{itemize}
 \item \lstinline!PRODUCER! inherits from \lstinline!CP_STARTABLE!.
 \item The \lstinline!PRODUCER! uses a \lstinline!CP_QUEUE_PROXY! instead of the \lstinline!CP_QUEUE!.
 \item The generated strings are not separate.
\end{itemize}

The classes \lstinline!CP_STARTABLE! and \lstinline!CP_STARTABLE_UTILS! are a useful combination.
They allow to start some operation on a separate object without the need for a specialized wrapper function.

Another nice utility is the \lstinline!CP_QUEUE_PROXY!.
It is part of a pattern which is often used throughout the library - the separate proxy \todo{add reference}.
Basically it allows to access a separate queue without the need to deal with separate references.

The really interesting thing however is that the producer can generate strings on its local processor.
Usually this is not possible, because if the string is later passed to a consumer object, the latter needs to lock the producer in order to get access to the string.
But in this case we instructed the queue object to import all string objects. During a call to \lstinline!queue_wrapper.put(item)! the following happens:
\begin{itemize}
 \item The producer waits until it gets exclusive access to the queue.
 \item The separate call is executed. Because \lstinline!item! is a non-separate reference, the call is synchronous and lock passing happens.
 \item The queue object imports the separate string, creating a local copy.
 \item The separate call terminates, both processors can proceed autonomously.
\end{itemize}
Creating the strings on a separate processor is therefore unnecessary.

The import trick avoids a lot of unnecessary thread creation:
Instead of creating a new processor for every single produced item we just copy it, which is much faster for small objects.

The consumer is basically the same as the producer, except for the feature \lstinline!start!:

\begin{lstlisting}
class
  CONSUMER
--...
  
	start
			-- Consume `item_count' items.
		local
			i: INTEGER
			item: STRING
		do
			from
				i := 1
			until
				i > item_count
			loop
				queue_wrapper.consume

				check attached queue_wrapper.last_consumed_item as l_item then

						-- Note that `item' is not declared as separate, because it has been
						-- imported automatically.
					item := l_item
					print (item + " // Consumer " + identifier.out + ": item " + i.out + "%N")
				end
				i := i + 1
			end
		end
end
\end{lstlisting}

You might notice again that the consumed string is not declared as separate.
This is again because of the import mechanism within \lstinline!CP_QUEUE!.

The last thing we need to do is to create and launch the producers and consumers in the main application:

\lstinputlisting [firstline=7] {../../examples/producer_consumer/producer_consumer.e}


\subsubsection{Server thread}

\subsubsection{Futures}

\subsection {Architecture and modules}
\label{sec:modules}

\section {Individual patterns}
% Description of a few patterns

\subsection{Evaluation and Benchmarks}

\section{Conclusion}

\todos
\end{document}          
